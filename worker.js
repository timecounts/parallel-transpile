// Generated by CoffeeScript 1.10.0
var EnhancedResolve, Path, SourceMapConsumer, SourceMapGenerator, fs, init, loaders, mkdirp, output, ref, send, source, utils;

fs = require('fs');

Path = require('path');

mkdirp = require('mkdirp');

utils = require('./utils');

ref = require('source-map'), SourceMapGenerator = ref.SourceMapGenerator, SourceMapConsumer = ref.SourceMapConsumer;

EnhancedResolve = require('enhanced-resolve');

loaders = {};

source = null;

output = null;

send = function(message) {
  if (message instanceof Error) {
    console.error(message.stack);
    message = {
      error: true,
      message: message.toString(),
      stack: message.stack
    };
  }
  return process.send(message);
};

init = function(options) {
  source = options.source.replace(/\/*$/, "/");
  output = options.output.replace(/\/+$/, "");
  return process.chdir(source);
};

process.on('message', function(m) {
  var _, absoluteOutPath, absolutePath, applyNext, baseName, details, err, error, error1, finished, fullPath, i, inExt, inFile, j, len, loader, loaderModule, mapPath, moduleName, obj, outExt, outFile, outPath, path, prevFile, query, ref1, ref2, relativePath, remainingLoaderModules, requestString, sourceMaps, src, stat, webpackLoaders;
  try {
    if (m.init) {
      return init(m.init);
    }
    if (!source) {
      throw new Error("Not initialised");
    }
    path = m.path, (ref1 = m.rule, inExt = ref1.inExt, loaders = ref1.loaders, outExt = ref1.outExt);
    fullPath = Path.resolve(path);
    relativePath = path.substr(source.length);
    outPath = output + "/" + (utils.swapExtension(relativePath, inExt, outExt));
    mapPath = output + "/" + (utils.swapExtension(relativePath, inExt, ".map"));
    webpackLoaders = [];
    baseName = Path.basename(relativePath);
    requestString = baseName;
    for (j = 0, len = loaders.length; j < len; j++) {
      loader = loaders[j];
      try {
        requestString = loader + "!" + requestString;
        ref2 = loader.match(/^([^?]+)(\?.*)?$/), _ = ref2[0], moduleName = ref2[1], query = ref2[2];
        loaderModule = require(moduleName);
        webpackLoaders.push({
          request: requestString,
          path: baseName,
          query: query,
          module: loaderModule
        });
      } catch (error) {
        err = error;
        return send(err);
      }
    }
    src = fs.readFileSync(path);
    sourceMaps = [];
    remainingLoaderModules = webpackLoaders.slice(0);
    i = remainingLoaderModules.length;
    finished = function() {
      var compoundMap, last, nextMap, sourceMapString;
      mkdirp.sync(Path.dirname(outPath));
      if (sourceMaps.length && outPath.match(/\.js$/)) {
        if (sourceMaps.length === 1) {
          sourceMapString = JSON.stringify(sourceMaps[0]);
        } else {
          last = sourceMaps.pop();
          compoundMap = SourceMapGenerator.fromSourceMap(new SourceMapConsumer(JSON.stringify(last)));
          while (nextMap = sourceMaps.pop()) {
            compoundMap.applySourceMap(new SourceMapConsumer(JSON.stringify(nextMap)));
          }
          sourceMapString = compoundMap.toString();
        }
        src = (src.toString('utf8')) + "\n//# sourceMappingURL=" + (Path.basename(mapPath));
      }
      fs.writeFileSync(outPath, src);
      if (sourceMapString) {
        fs.writeFileSync(mapPath, sourceMapString);
      }
      return send({
        msg: 'complete',
        details: details
      });
    };
    absoluteOutPath = Path.resolve(outPath);
    absolutePath = Path.resolve(path);
    stat = fs.statSync(absolutePath);
    inFile = Path.relative(Path.dirname(absoluteOutPath), absolutePath);
    outFile = Path.basename(outPath);
    prevFile = inFile;
    details = {
      outPath: absoluteOutPath,
      dependencies: (
        obj = {},
        obj["" + absolutePath] = {
          mtime: +stat.mtime
        },
        obj
      )
    };
    applyNext = function() {
      var addDependency, asyncCallback, cacheable, context, error1, input, next, out;
      next = remainingLoaderModules.pop();
      i--;
      if (!next) {
        return finished();
      }
      asyncCallback = false;
      cacheable = false;
      context = {
        options: {},
        cacheable: function(_cacheable) {
          if (_cacheable == null) {
            _cacheable = true;
          }
          return cacheable = _cacheable;
        },
        version: 1,
        request: next.request,
        context: Path.dirname(fullPath),
        path: next.path,
        resource: baseName,
        resourcePath: baseName,
        resourceQuery: "",
        query: next.query,
        sourceMap: true,
        loaderIndex: i,
        loaders: webpackLoaders,
        addDependency: addDependency = function(file) {
          var e, error1, fileStat;
          try {
            fileStat = fs.statSync(Path.resolve(file));
            return details.dependencies[Path.resolve(file)] = {
              mtime: +fileStat.mtime
            };
          } catch (error1) {
            e = error1;
            console.error("FAILED TO STAT DEPENDENCY '" + file + "' of '" + inFile + "'");
            return details.dependencies[Path.resolve(file)] = {
              mtime: 0
            };
          }
        },
        dependency: addDependency,
        resolveSync: EnhancedResolve.sync,
        resolve: EnhancedResolve,
        async: function() {
          asyncCallback = true;
          return context.callback;
        },
        callback: function(err, out, map) {
          asyncCallback = true;
          if (err) {
            send(err);
            return;
          }
          if (out instanceof Buffer) {
            src = out;
          } else {
            src = new Buffer(out);
          }
          if (map) {
            map.sources = [prevFile];
            if (i > 0) {
              map.file = outFile + "-" + i;
            } else {
              map.file = outFile;
            }
            prevFile = map.file;
            delete map.sourcesContent;
            sourceMaps.push(map);
          }
          return applyNext();
        }
      };
      try {
        if (next.module.raw) {
          input = src;
        } else {
          input = src.toString('utf8');
        }
        out = next.module.call(context, input);
        if (!asyncCallback) {
          if (out instanceof Buffer) {
            src = out;
          } else {
            src = new Buffer(out);
          }
          return applyNext();
        }
      } catch (error1) {
        err = error1;
        send(err);
      }
    };
    return applyNext();
  } catch (error1) {
    err = error1;
    return send(err);
  }
});

//# sourceMappingURL=worker.js.map
